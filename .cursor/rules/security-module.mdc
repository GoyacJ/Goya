---
alwaysApply: false
globs:
  - "**/component-security/**/*.java"
  - "**/security/**/*.java"
---

# 安全模块专项规则

## 适用范围
本规则适用于所有安全相关的代码开发，包括认证、授权、OAuth2、JWT 等。

## 核心原则

1. **安全第一**：所有安全相关代码必须经过严格审查
2. **最小权限**：默认拒绝，显式授权
3. **防御深度**：多层安全防护
4. **审计追踪**：所有安全事件必须记录

## 密码处理

### 密码加密

```java
// ✅ 正确 - 使用 BCrypt
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(10);  // 强度不低于 10
}

// ❌ 错误 - 不要使用弱加密
@Bean
public PasswordEncoder passwordEncoder() {
    return NoOpPasswordEncoder.getInstance();  // 禁止
}
```

### 密码验证

```java
// ✅ 正确
public boolean verifyPassword(String rawPassword, String encodedPassword) {
    return passwordEncoder.matches(rawPassword, encodedPassword);
}

// ❌ 错误 - 不要明文比较
public boolean verifyPassword(String password1, String password2) {
    return password1.equals(password2);
}
```

## Token 处理

### JWT 生成

```java
/**
 * 生成 JWT Token
 * <p>
 * Token 必须包含：iss, sub, aud, exp, iat, jti
 * 敏感信息（如密码）不得包含在 Token 中
 */
public String generateToken(SecurityUser user) {
    return Jwts.builder()
        .issuer("https://auth.example.com")
        .subject(user.getUsername())
        .audience().add("api.example.com").and()
        .expiration(Date.from(Instant.now().plus(15, ChronoUnit.MINUTES)))
        .issuedAt(new Date())
        .id(UUID.randomUUID().toString())
        .claim("tenant_id", user.getTenantId())
        .claim("roles", user.getRoles())
        .signWith(privateKey, Jwts.SIG.RS256)
        .compact();
}
```

### Token 验证

```java
/**
 * 验证 JWT Token
 * <p>
 * 必须验证：签名、过期时间、Issuer、Audience
 * 必须检查黑名单
 */
public Jwt verifyToken(String token) {
    // 1. 检查黑名单
    if (blacklistService.isBlacklisted(token)) {
        throw new InvalidTokenException("Token has been revoked");
    }
    
    // 2. 验证签名和Claims
    try {
        return jwtDecoder.decode(token);
    } catch (JwtException e) {
        log.error("[Goya] |- Token verification failed", e);
        throw new InvalidTokenException("Invalid token");
    }
}
```

## OAuth2 开发

### Client 配置

```java
/**
 * 注册 OAuth2 Client
 * <p>
 * Client Secret 必须加密存储
 * 必须验证 Redirect URI
 */
public RegisteredClient createClient(ClientRequest request) {
    return RegisteredClient.withId(UUID.randomUUID().toString())
        .clientId(request.getClientId())
        .clientSecret(passwordEncoder.encode(request.getClientSecret()))  // 必须加密
        .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
        .redirectUri(validateRedirectUri(request.getRedirectUri()))  // 必须验证
        .scope("read")
        .scope("write")
        .build();
}
```

### 授权码生成

```java
/**
 * 生成授权码
 * <p>
 * 授权码必须：
 * - 一次性使用
 * - 短有效期（10分钟）
 * - 绑定 Client 和 User
 */
public String generateAuthorizationCode(String clientId, String username) {
    String code = RandomStringUtils.randomAlphanumeric(32);
    
    // 存储授权码（Redis，10分钟过期）
    AuthorizationCode authCode = AuthorizationCode.builder()
        .code(code)
        .clientId(clientId)
        .username(username)
        .expiresAt(Instant.now().plus(10, ChronoUnit.MINUTES))
        .used(false)
        .build();
    
    authorizationCodeRepository.save(authCode);
    
    return code;
}
```

## 权限控制

### 注解式权限

```java
// ✅ 使用 @PreAuthorize
@PreAuthorize("hasRole('ADMIN')")
public void deleteUser(Long id) {
    userRepository.deleteById(id);
}

@PreAuthorize("hasAuthority('user:write') and #user.id == authentication.principal.id")
public void updateUser(User user) {
    userRepository.save(user);
}
```

### 编程式权限

```java
/**
 * 编程式权限验证
 */
public void performAction(String action) {
    Authentication auth = SecurityContextHolder.getContext().getAuthentication();
    
    if (!hasPermission(auth, action)) {
        log.warn("[Goya] |- Access denied: user={}, action={}", 
            auth.getName(), action);
        throw new AccessDeniedException("无权限执行此操作");
    }
    
    // 执行操作
}
```

## 多租户隔离

### 租户上下文

```java
/**
 * 租户上下文
 * <p>
 * 使用 ThreadLocal 存储当前租户
 * 必须在请求结束时清理
 */
public class TenantContext {
    private static final ThreadLocal<String> TENANT = new ThreadLocal<>();
    
    public static void setTenant(String tenant) {
        log.trace("[Goya] |- Setting tenant: {}", tenant);
        TENANT.set(tenant);
    }
    
    public static String getTenant() {
        return TENANT.get();
    }
    
    public static void clear() {
        log.trace("[Goya] |- Clearing tenant context");
        TENANT.remove();
    }
}
```

### 数据隔离

```java
/**
 * MyBatis Plus 租户拦截器
 */
@Component
public class TenantLineHandler implements TenantLineHandler {
    
    @Override
    public Expression getTenantId() {
        String tenant = TenantContext.getTenant();
        if (tenant == null) {
            throw new TenantNotFoundException("Tenant not found in context");
        }
        return new StringValue(tenant);
    }
    
    @Override
    public String getTenantIdColumn() {
        return "tenant_id";
    }
    
    @Override
    public boolean ignoreTable(String tableName) {
        // 系统表不拦截
        return tableName.startsWith("sys_");
    }
}
```

## 安全审计

### 审计日志

```java
/**
 * 安全审计日志
 * <p>
 * 必须记录：谁、何时、做了什么、结果如何
 */
@Slf4j
@Aspect
@Component
public class SecurityAuditAspect {
    
    @AfterReturning(pointcut = "@annotation(securityAudit)", returning = "result")
    public void audit(JoinPoint jp, SecurityAudit securityAudit, Object result) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        
        AuditLog auditLog = AuditLog.builder()
            .username(auth.getName())
            .action(securityAudit.action())
            .resource(securityAudit.resource())
            .result("SUCCESS")
            .ip(getClientIp())
            .userAgent(getUserAgent())
            .timestamp(Instant.now())
            .build();
        
        auditLogRepository.save(auditLog);
        
        log.info("[Goya] |- Security audit: user={}, action={}, resource={}", 
            auth.getName(), securityAudit.action(), securityAudit.resource());
    }
}
```

## 安全检查清单

### 认证
- [ ] 密码使用 BCrypt 加密（强度 >= 10）
- [ ] 登录失败次数限制
- [ ] 验证码防暴力破解
- [ ] Session 固定攻击防护

### 授权
- [ ] 默认拒绝访问
- [ ] 细粒度权限控制
- [ ] 资源级别授权
- [ ] 租户数据隔离

### Token
- [ ] JWT 使用 RS256 签名
- [ ] Token 短有效期（<= 30分钟）
- [ ] Refresh Token 轮换
- [ ] Token 黑名单机制

### 传输
- [ ] 强制 HTTPS
- [ ] HSTS 头部
- [ ] Secure Cookie
- [ ] CSRF 防护

### 审计
- [ ] 登录/登出记录
- [ ] 权限变更记录
- [ ] 敏感操作记录
- [ ] 异常访问告警

## 禁止事项

1. ❌ **禁止明文存储密码**
2. ❌ **禁止在日志中输出密码、Token**
3. ❌ **禁止硬编码密钥**
4. ❌ **禁止使用弱加密算法**（MD5, SHA1）
5. ❌ **禁止跳过权限验证**
6. ❌ **禁止在 Token 中存储敏感信息**
7. ❌ **禁止使用 GET 请求传递敏感参数**

## 参考资料

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [OAuth 2.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-09)
- [JWT Best Practices](https://datatracker.ietf.org/doc/html/rfc8725)
